<?php

declare(strict_types=1);

namespace Prox\ProxGallery\Modules\DevelopmentSeed\Services;

use Prox\ProxGallery\Contracts\ServiceInterface;
use Prox\ProxGallery\Modules\Gallery\Services\GalleryService;
use Prox\ProxGallery\Modules\MediaLibrary\Models\UploadedImageQueueModel;
use Prox\ProxGallery\Modules\MediaLibrary\Services\MediaCategoryService;
use Prox\ProxGallery\Modules\MediaLibrary\Services\TrackUploadedImageService;
use Prox\ProxGallery\Services\FrontendGalleryService;

/**
 * Generates development seed data for media, galleries, and categories.
 */
final class DevelopmentSeedService implements ServiceInterface
{
    private const ONE_PIXEL_PNG_BASE64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO7ZlYQAAAAASUVORK5CYII=';

    /**
     * @var list<string>
     */
    private const CATEGORY_POOL = [
        'Nature',
        'Urban',
        'Portrait',
        'Travel',
        'Macro',
        'Architecture',
        'Landscape',
        'Street',
        'Black and White',
        'Editorial',
        'Night',
        'Food',
        'Product',
        'Documentary',
        'Fashion',
        'Minimal',
        'Adventure',
        'Coastal',
        'Mountains',
        'Wildlife',
    ];

    /**
     * @var list<string>
     */
    private const TITLE_PREFIXES = [
        'Golden',
        'Silent',
        'Wild',
        'Calm',
        'Northern',
        'Crimson',
        'Azure',
        'Echo',
        'Lunar',
        'Solar',
    ];

    /**
     * @var list<string>
     */
    private const TITLE_SUFFIXES = [
        'Horizon',
        'Frame',
        'Moment',
        'Story',
        'Capture',
        'Scene',
        'Vista',
        'Archive',
        'Memoir',
        'Signal',
    ];

    public function __construct(
        private GalleryService $galleryService,
        private FrontendGalleryService $frontendGalleryService,
        private MediaCategoryService $mediaCategoryService,
        private TrackUploadedImageService $trackService,
        private UploadedImageQueueModel $queue
    )
    {
    }

    public function id(): string
    {
        return 'development.seed.service';
    }

    public function boot(): void
    {
        /**
         * Fires after development seed services are booted.
         */
        \do_action('prox_gallery/module/development_seed/service/booted', $this);
    }

    /**
     * @return array{
     *     requested_images:int,
     *     created_images:int,
     *     failed_images:int,
     *     requested_galleries:int,
     *     created_galleries:int,
     *     tracked_images:int,
     *     gallery_assignments:int,
     *     category_assignments:int,
     *     galleries:list<array{id:int, name:string, template:string}>
     * }
     */
    public function importRandomData(
        int $imageCount = 100,
        int $galleryCount = 6,
        int $maxCategoriesPerImage = 3,
        int $maxGalleriesPerImage = 3,
        bool $clearExisting = false
    ): array
    {
        $sanitizedImageCount = max(1, $imageCount);
        $sanitizedGalleryCount = max(1, $galleryCount);
        $sanitizedMaxCategories = max(0, $maxCategoriesPerImage);
        $sanitizedMaxGalleries = max(1, $maxGalleriesPerImage);

        if ($clearExisting) {
            \delete_option('prox_gallery_galleries');
            $this->queue->replaceAll([]);
        }

        $galleryRows = [];
        $galleryIds = [];
        $galleryTemplatePool = $this->availableTemplateSlugs();

        for ($index = 1; $index <= $sanitizedGalleryCount; $index++) {
            $template = $this->pickRandomString($galleryTemplatePool, 'basic-grid');
            $gallery = $this->galleryService->create(
                sprintf('Seed Gallery %d', $index),
                sprintf('Generated by prox seed import-random at %s', \gmdate('c')),
                $template
            );

            $galleryIds[] = (int) $gallery['id'];
            $galleryRows[] = [
                'id' => (int) $gallery['id'],
                'name' => (string) $gallery['name'],
                'template' => (string) $gallery['template'],
            ];
        }

        $createdImages = 0;
        $failedImages = 0;
        $trackedImages = 0;
        $galleryAssignments = 0;
        $categoryAssignments = 0;

        for ($index = 1; $index <= $sanitizedImageCount; $index++) {
            $attachmentId = $this->createSeedAttachment($index);

            if ($attachmentId <= 0) {
                $failedImages++;
                continue;
            }

            $createdImages++;

            if ($this->trackService->track($attachmentId)) {
                $trackedImages++;
            }

            $galleriesForImage = $this->pickRandomIntIds(
                $galleryIds,
                random_int(1, min($sanitizedMaxGalleries, count($galleryIds)))
            );
            $this->galleryService->setImageGalleries($attachmentId, $galleriesForImage);
            $galleryAssignments += count($galleriesForImage);

            if ($sanitizedMaxCategories > 0) {
                $categories = $this->pickRandomStrings(
                    self::CATEGORY_POOL,
                    random_int(0, $sanitizedMaxCategories)
                );

                if ($categories !== []) {
                    $this->mediaCategoryService->assignToAttachment($attachmentId, $categories);
                    $categoryAssignments += count($categories);
                }
            }
        }

        return [
            'requested_images' => $sanitizedImageCount,
            'created_images' => $createdImages,
            'failed_images' => $failedImages,
            'requested_galleries' => $sanitizedGalleryCount,
            'created_galleries' => count($galleryRows),
            'tracked_images' => $trackedImages,
            'gallery_assignments' => $galleryAssignments,
            'category_assignments' => $categoryAssignments,
            'galleries' => $galleryRows,
        ];
    }

    private function createSeedAttachment(int $index): int
    {
        $image = $this->buildSeedImagePayload($index);

        if ($image === null) {
            return 0;
        }

        $upload = \wp_upload_bits(
            $image['filename'],
            null,
            $image['binary']
        );

        $uploadError = isset($upload['error']) ? (string) $upload['error'] : '';

        if ($uploadError !== '' || ! isset($upload['file']) || ! is_string($upload['file'])) {
            return 0;
        }

        $title = sprintf('%s %s %d', $this->randomTitlePrefix(), $this->randomTitleSuffix(), $index);

        $attachmentId = \wp_insert_attachment(
            [
                'post_title' => $title,
                'post_mime_type' => $image['mime_type'],
                'post_status' => 'inherit',
                'post_type' => 'attachment',
            ],
            $upload['file']
        );

        if (! is_int($attachmentId) || $attachmentId <= 0) {
            return 0;
        }

        if (! function_exists('wp_generate_attachment_metadata')) {
            require_once \ABSPATH . 'wp-admin/includes/image.php';
        }

        if (function_exists('wp_generate_attachment_metadata')) {
            $metadata = \wp_generate_attachment_metadata($attachmentId, $upload['file']);

            if (is_array($metadata) && function_exists('wp_update_attachment_metadata')) {
                \wp_update_attachment_metadata($attachmentId, $metadata);
            }
        }

        return $attachmentId;
    }

    /**
     * @return array{filename:string, mime_type:string, binary:string}|null
     */
    private function buildSeedImagePayload(int $index): ?array
    {
        if (function_exists('imagecreatetruecolor') && function_exists('imagejpeg')) {
            $width = random_int(900, 1800);
            $height = random_int(700, 1300);
            $resource = imagecreatetruecolor($width, $height);

            if ($resource === false) {
                return null;
            }

            $topR = random_int(10, 180);
            $topG = random_int(10, 180);
            $topB = random_int(10, 180);
            $bottomR = random_int(60, 240);
            $bottomG = random_int(60, 240);
            $bottomB = random_int(60, 240);

            for ($y = 0; $y < $height; $y++) {
                $mix = $height > 1 ? $y / ($height - 1) : 0;
                $r = (int) round($topR + (($bottomR - $topR) * $mix));
                $g = (int) round($topG + (($bottomG - $topG) * $mix));
                $b = (int) round($topB + (($bottomB - $topB) * $mix));
                $lineColor = imagecolorallocate($resource, $r, $g, $b);

                if ($lineColor === false) {
                    continue;
                }

                imageline($resource, 0, $y, $width, $y, $lineColor);
            }

            $shapeCount = random_int(8, 18);

            for ($i = 0; $i < $shapeCount; $i++) {
                $color = imagecolorallocatealpha(
                    $resource,
                    random_int(30, 255),
                    random_int(30, 255),
                    random_int(30, 255),
                    random_int(50, 95)
                );

                if ($color === false) {
                    continue;
                }

                imagefilledellipse(
                    $resource,
                    random_int(0, $width),
                    random_int(0, $height),
                    random_int((int) floor($width * 0.05), (int) floor($width * 0.45)),
                    random_int((int) floor($height * 0.05), (int) floor($height * 0.45)),
                    $color
                );
            }

            $overlay = imagecolorallocatealpha($resource, 255, 255, 255, 70);
            if ($overlay !== false) {
                imagestring($resource, 5, 14, 14, sprintf('PROX SEED %04d', $index), $overlay);
            }

            ob_start();
            imagejpeg($resource, null, 87);
            $binary = (string) ob_get_clean();
            imagedestroy($resource);

            if ($binary === '') {
                return null;
            }

            return [
                'filename' => sprintf('prox-seed-%s-%04d.jpg', \gmdate('YmdHis'), $index),
                'mime_type' => 'image/jpeg',
                'binary' => $binary,
            ];
        }

        $fallback = (string) \base64_decode(self::ONE_PIXEL_PNG_BASE64);

        if ($fallback === '') {
            return null;
        }

        return [
            'filename' => sprintf('prox-seed-%s-%04d.png', \gmdate('YmdHis'), $index),
            'mime_type' => 'image/png',
            'binary' => $fallback,
        ];
    }

    private function randomTitlePrefix(): string
    {
        return $this->pickRandomString(self::TITLE_PREFIXES, 'Seed');
    }

    private function randomTitleSuffix(): string
    {
        return $this->pickRandomString(self::TITLE_SUFFIXES, 'Image');
    }

    /**
     * @return list<string>
     */
    private function availableTemplateSlugs(): array
    {
        $rows = $this->frontendGalleryService->templateCatalog();
        $slugs = [];

        foreach ($rows as $row) {
            if (! is_array($row)) {
                continue;
            }

            $slug = isset($row['slug']) ? (string) $row['slug'] : '';
            $available = isset($row['available']) && (bool) $row['available'];

            if ($slug === '' || ! $available) {
                continue;
            }

            $slugs[] = $slug;
        }

        if ($slugs === []) {
            return ['basic-grid'];
        }

        return array_values(array_unique($slugs));
    }

    /**
     * @param list<int> $source
     *
     * @return list<int>
     */
    private function pickRandomIntIds(array $source, int $count): array
    {
        if ($source === []) {
            return [];
        }

        $copy = array_values(array_unique($source));
        shuffle($copy);

        return array_slice($copy, 0, max(0, min($count, count($copy))));
    }

    /**
     * @param list<string> $source
     *
     * @return list<string>
     */
    private function pickRandomStrings(array $source, int $count): array
    {
        if ($source === []) {
            return [];
        }

        $copy = array_values(array_unique($source));
        shuffle($copy);

        return array_slice($copy, 0, max(0, min($count, count($copy))));
    }

    /**
     * @param list<string> $source
     */
    private function pickRandomString(array $source, string $fallback): string
    {
        if ($source === []) {
            return $fallback;
        }

        $index = random_int(0, count($source) - 1);
        $value = isset($source[$index]) ? (string) $source[$index] : '';

        return $value !== '' ? $value : $fallback;
    }
}
